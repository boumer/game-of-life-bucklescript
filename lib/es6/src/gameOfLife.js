// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE
'use strict';

import * as Lst        from "./lst.js";
import * as $$Set      from "bs-platform/lib/es6/set.js";
import * as List       from "bs-platform/lib/es6/list.js";
import * as Curry      from "bs-platform/lib/es6/curry.js";
import * as Rules      from "./rules.js";
import * as Caml_obj   from "bs-platform/lib/es6/caml_obj.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";

function $less$less(f, g, x) {
  return Curry._1(f, Curry._1(g, x));
}

function isNeighbour(param, param$1) {
  var y2 = param$1[1];
  var x2 = param$1[0];
  var y1 = param[1];
  var x1 = param[0];
  if (Pervasives.abs(x1 - x2 | 0) <= 1 && Pervasives.abs(y1 - y2 | 0) <= 1) {
    return 1 - +(x1 === x2 && y1 === y2);
  } else {
    return /* false */0;
  }
}

function findNeighbours(universe, position) {
  return List.map(function (prim) {
              return prim[1];
            }, List.filter(function (param) {
                    return isNeighbour(position, param[0]);
                  })(universe));
}

function evolveCell(universe, param) {
  var position = param[0];
  var neighbours = findNeighbours(universe, position);
  var evolvedCell = Rules.applyRules(param[1], neighbours);
  return /* tuple */[
          position,
          evolvedCell
        ];
}

function findMaybeCell(universe, param) {
  var y = param[1];
  var x = param[0];
  var inBounds = function (param) {
    var match = param[0];
    if (match[0] === x) {
      return +(match[1] === y);
    } else {
      return /* false */0;
    }
  };
  return Lst.head(List.filter(inBounds)(universe));
}

function findCell(universe, position) {
  var match = findMaybeCell(universe, position);
  if (match) {
    return /* tuple */[
            position,
            match[0][1]
          ];
  } else {
    return /* tuple */[
            position,
            /* Dead */1
          ];
  }
}

var compare = Caml_obj.caml_compare;

var PosSet = $$Set.Make(/* module */[/* compare */compare]);

function dedupe(universe) {
  var positions = List.map(function (prim) {
        return prim[0];
      }, universe);
  var dedupedPositions = Curry._1(PosSet[/* elements */19], Curry._1(PosSet[/* of_list */25], positions));
  return List.map(function (param) {
              return findCell(universe, param);
            }, dedupedPositions);
}

function evolve(universe) {
  var otherPositions = function (param) {
    var y = param[1];
    var x = param[0];
    return /* :: */[
            /* tuple */[
              x - 1 | 0,
              y - 1 | 0
            ],
            /* :: */[
              /* tuple */[
                x,
                y - 1 | 0
              ],
              /* :: */[
                /* tuple */[
                  x + 1 | 0,
                  y - 1 | 0
                ],
                /* :: */[
                  /* tuple */[
                    x - 1 | 0,
                    y
                  ],
                  /* :: */[
                    /* tuple */[
                      x + 1 | 0,
                      y
                    ],
                    /* :: */[
                      /* tuple */[
                        x - 1 | 0,
                        y + 1 | 0
                      ],
                      /* :: */[
                        /* tuple */[
                          x,
                          y + 1 | 0
                        ],
                        /* :: */[
                          /* tuple */[
                            x + 1 | 0,
                            y + 1 | 0
                          ],
                          /* [] */0
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ];
  };
  var cells = function (position) {
    return List.map(function (param) {
                return findCell(universe, param);
              }, otherPositions(position));
  };
  var currentUniverse = dedupe(List.concat(List.map(cells, List.map(function (prim) {
                    return prim[0];
                  }, universe))));
  return List.filter(function (param) {
                return +(/* Alive */0 === param[1]);
              })(List.map(function (param) {
                  return evolveCell(universe, param);
                }, currentUniverse));
}

var applyRules = Rules.applyRules;

export {
  applyRules     ,
  $less$less     ,
  isNeighbour    ,
  findNeighbours ,
  evolveCell     ,
  findMaybeCell  ,
  findCell       ,
  PosSet         ,
  dedupe         ,
  evolve         ,
  
}
/* PosSet Not a pure module */
